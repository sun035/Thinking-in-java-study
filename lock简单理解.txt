

  Lock对象必须被显式的创建，锁定，或释放，但是相对来说也更加灵活，
使用lock()和unLick()方法进行建立临界资源，通常必须放置在try catch 语句中，return语句必须在try 子句中，以防止unLick（）过早发生、
如果使用synchronized，当某些事物失败就会抛出异常，但是你没有机会做清理操作，Lock可以在finally{}中将系统恢复正常状态



显示的lock对象拥有更细的颗粒度控制，这对于实现专有同步结构是很有用的 例如遍历列表链接中的节点的节点传递的加锁机制（也称锁耦合）
这种遍历代码必须在释放当前节点的锁之前捕获下一节点的锁 


原子性与易变性



当你定义long或double时 使用volatile关键字可保证原子性，但通常我们并不依赖于此
volatile还确保了应用中的可视性 如果你讲一个域设置为volatile的 那么只要对这个域产生了写操作 那么所有的读操作都可以看到这个修改
即使使用了本地缓存 情况也是如此 volatile域会立即写入主内存中 而读操作正是发生在主内存，synchronized同样也可以导致主内存刷新











