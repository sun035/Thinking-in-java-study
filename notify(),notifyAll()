

通常 使用notify()是一种优化，在使用notify()时，在众多等待同一个锁的任务中只会有一个被唤醒
因此，如果你希望使用notity()要确保所唤醒的是恰当的任务，并且 为了使用notify() 所有任务必须等待相同的条件
如果你有多个任务等待多个条件 那么你就不能确保所唤醒的是恰当的任务 
如果使用notify() 当条件发生变化时 必须只有一个任务能够从中受益，最后 这些限制对所有可能存在的子类都必须起到作用
，如果以上规则有一条不满足则应当使用notifyAll()




notifyAll（）是否会唤醒所有等待的任务？

答：不会，只会唤醒同一对象上的锁，即只有等待这个锁的任务才会被唤醒



在更复杂的情况下，可能会有多个任务在某个特定对象锁上等待，因此你不知道那个任务应该被唤醒，一般调用notifyAll()更安全
这样可以在唤醒等待这个锁的所有任务，而每个任务都必须决定这个通知是都跟自己相关



显示的lock和condition对象

使用互斥并允许任务挂起的是基本类condition 可以通过调用condition中的awit()方法将任务挂起
当外部条件发生变化，意味着某个任务将应该继续执行，这里通过condition的signal()进行唤醒（或者signalAll() 它将比notifyAll更安全
注意 在调用这些方法的时候必须保证拥有对象上的锁！！！




