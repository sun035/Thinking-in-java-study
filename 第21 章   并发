21.2  
       并发编程使我们可以将程序划分为多个分离的,独立运行的任务。通过使用多线程机制，这些独立的子任务中的每一个都将由独立线程来驱动
一个线程就是在进程中的一个单一的顺序控制流，因此单个进程又多个并发的子线程组成，但是你的程序都使得你的每个任务都在独自使用cup一样，其底层机制是通过切分cpu时间




21.2.3使用连接池(Executor)


    连接池用来管理Thread对象，从而简化并发编程，她在客户端与任务之间提供了一个间接层，任务的执行将交给连接池，我们无需考虑线程的生命周期，
    我们可以通过静态的Executor来创建ExecutorService对象（具有管理线程生命周期，知道如何以合适的上下文来构建Runable对象），对其shutdown()方法的调用可以防止新任务被提交给这个线程池
    不同类型的连接池有不同的作用：
    cachedThreadPool通常在程序运行期间创建与所需数量相同的线程
    fixedThreadPool可以一次性的预先创建所需要的线程数量的线程分配，这可以节省时间
    singleThreadPool就像数量是1的fixedThreadPool，如果向它提交多个任务将会进行排队按顺序执行任务（它会序列化所提交给他的任务，并维护自己的悬挂任务队列 ）
    
    
    
 21.2.5休眠
    通过Thread.sleep()可以将当前线程休眠（即阻塞），setPriprity()来修改优先级（并不绝对，jdk有10个优先级但是与多数操作系统不能很好的映射），
    可以通过yield()进行暗示当前任务进行切换（不绝对一定会被采纳）
