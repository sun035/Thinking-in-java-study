Thread.interrupt()，可以终止被阻塞的任务，这个方法将设置线程的中断状态， 当一个线程被阻塞或者将要试图进行一个阻塞操作
将抛出该异常或者该任务调用Thread.interrupted(),将中断状态复位，Thread.interrupted()提供了离开run()方法循环而不抛出异常的第二种方式（??还是没理解）



只要任务以不可中断的方式被阻塞，那么都有被潜在的被锁住的可能，jse5中ReentranLock上阻塞的任务具备了可以中断的能力


中断发生的唯一时刻就是任务要进入阻塞状态当中，或者已经在阻塞操作内部时（除了不可中断的io或synchronize方法外）


任务之间的协调合作：

当你使用线程来同时运行多个资源时，加锁（互斥）能保证多个任务在访问共享资源（通常是内存）时不会进行争抢
那么任务之间是如何互相协作，以使得多个任务可以一起工作去解决某个问题，现在问题不是彼此的互斥而是彼此的协调

为了实现这样的握手，使用了相同的基础特性，互斥  但在此基础之上添加了一种途径 可以将自身挂起，直到某些外部条件发生变化
表示是时候让这个任务向前开动为止，这可以通过object的wait和notify等实现





